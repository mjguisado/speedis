import { createClient } from 'redis'

import http from 'http'
import https from 'https'
// import http2 from 'http2'
import os from 'os'

import tlch from '../transformers/toLowerCaseHeaders.js'
import aorh from '../transformers/addOrReplaceHeaders.js'
import * as utils from '../util/utils.js'

export default async function (server, opts) {
  // https://nodejs.org/api/http.html#httprequestoptions-callback
  // https://nodejs.org/api/http.html#new-agentoptions
  // https://github.com/redis/node-redis/blob/master/docs/client-configuration.md
  const { name, origin, agentOpts, redisOpts } = opts
  server.decorate('name', name)

  // Initially, we are only going to support GET requests.
  // The default method is GET
  if (origin.httpxoptions.method && origin.httpxoptions.method !== 'GET') {
    throw new Error(`Origin: ${name}. Unsupported HTTP method: ${origin.httpxoptions.method}. Only GET is supported.`)
  }
  // Ensuring the header array exists
  if (!Object.prototype.hasOwnProperty.call(origin.httpxoptions, 'headers')) {
    origin.httpxoptions.headers = []
  } else {
    // We ensure that header names are in lowercase for the following
    // comparisons, which are case-sensitive.
    // Node HTTP sets all headers to lower case automatically.
    tlch(origin.httpxoptions, null)
  }
  server.decorate('origin', origin)

  // Agents are responsible for managing connections.
  // For HTTP/2, you don’t need an agent per se, but you can maintain reusable
  // connections by configuring the HTTP/2 client instance.
  if (!origin.http2 && agentOpts) {
    // The default protocol is 'http:'
    const agent = (origin.httpxoptions.protocol === 'https:' ? https : http).Agent(agentOpts)
    origin.httpxoptions.agent = agent
    server.decorate('agent', agent)
  }

  // Connecting to Redis
  const client = await createClient(redisOpts)
    .on('error', err => {
      throw new Error(`Origin: ${name}. Error connecting to Redis.`, { cause: err })
    })
    .connect()
  server.decorate('redis', client)

  server.addHook('onClose', (server) => {
    if (server.agent) server.agent.destroy()
    if (server.redis) server.redis.quit()
  })

  /*
  server.get('/',
    {
      schema: {
        querystring: {
          type: 'object',
          properties: {
            oid: { type: 'string' },
            path: { type: 'string' },
            ff: { type: 'boolean' },
            pv: { type: 'boolean' }
          }
        }
      }
    },
    async (req, reply) => {
    }
  )
  */

  await _get('/objects?id=3&id=5&id=10', false, false)

  async function _get (path, forceFetch, preview) {
    // We create options for an HTTP/S request to the required path
    // based on the default ones that must not be modified.
    const options = { ...server.origin.httpxoptions, path }

    // We try to look for the entry in the cache.
    // FIXME: ¿Consultamos Redis incluso si nos fuerzan el fetch?
    // TODO: Recuperar sólo los campos que necesitamos: requestTime, responseTime, headers
    const cachedResponse = await server.redis.json.get(path)

    cachedResponse.headers['cache-control'] = 'max-age=30, s-maxage=300'

    if (cachedResponse) {
      // We calculate whether the cache entry is fresh or stale.
      // See: https://tools.ietf.org/html/rfc7234#section-4.2
      const freshnessLifetime = utils.calculateFreshnessLifetime(cachedResponse)
      const currentAge = utils.calculateAge(cachedResponse)
      const responseIsFresh = (freshnessLifetime > currentAge)

      /*
      * TODO: Evaluate whether to handle cache directives that force a request
      * to the origin. It should be analyzed whether to treat differently the
      * headers coming from the client request, which can be used to overload
      * the origin by attacking it, from those generated by the origin itself.
      * The latter, if considered a problem, can always be modified by a
      * transformer.
      *
      * https://tools.ietf.org/html/rfc7234#section-4.2.4
      * https://developer.mozilla.org/es/docs/Web/HTTP/Headers/Cache-Control
      *
      * &&
      *     ! (   cacheDirectives.hasOwnProperty('no-store')
      *        || cacheDirectives.hasOwnProperty('no-cache')
      *        || cacheDirectives.hasOwnProperty('must-revalidate')
      *        || cacheDirectives.hasOwnProperty('proxy-revalidate')))
      *     || cacheDirectives.hasOwnProperty('immutable')) {
      */

      /**
      * If the response is fresh, we serve it immediately from the cache.
      * It can be fresh for a specific period or indefinitely if it contains
      * the x-speedis-freshness-lifetime-infinity header.
      */
      if (!forceFetch && (utils.isFreshnessLifeTime(cachedResponse) || responseIsFresh)) {
        aorh(cachedResponse, { age: utils.calculateAge(cachedResponse) })
        utils.memHeader('HIT', forceFetch, preview, cachedResponse)
        return cachedResponse
      } else {
        // We need to revalidate the response through a conditional request.
        if ('etag' in cachedResponse.headers) {
          aorh(options, { 'if-none-match': cachedResponse.headers.etag })
        }
        if ('last-modified' in cachedResponse.headers) {
          aorh(options, { 'if-modified-since': cachedResponse.headers['last-modified'] })
        }
      }
    }

    // If we reach this point, it is because we need to make a request to
    // the origin to retrieve or revalidate the response.
    let outputResponse = null

    // The current value of the clock at the host at the time the
    // request resulting in the stored response was made.
    const requestTime = Date.now() / 1000 | 0

    // Make the request to the origin
    let originResponse = null
    let responseTime = null
    try {
      originResponse = await _fetch(options)
      // The current value of the clock at the host at the time the
      // response was received.
      responseTime = Date.now() / 1000 | 0
    } catch (err) {
      server.log.error(err,
        `Error while requesting to the origin ${server.name} with this options: ` +
        JSON.stringify(options)
      )

      /*
      * If I was trying to refresh a cache entry, I may consider serving the
      * stale content.
      * TODO: Evaluate whether to handle cache directives related to this.
      * https://tools.ietf.org/html/rfc7234#section-4.2.4
      * https://developer.mozilla.org/es/docs/Web/HTTP/Headers/Cache-Control
      */
      if (cachedResponse != null) {
        server.log.warn(err, `Serving stale content. Origin: ${server.name}. Key: ${path}.`)
        server.log.debug('Failed cache entry: ' + JSON.stringify(cachedResponse))
        aorh(cachedResponse, {
          warning: '111 ' + os.hostname() + ' "Revalidation Failed" "' + (new Date()).toUTCString() + '"',
          age: utils.calculateAge(cachedResponse)
        })
        utils.memHeader('STALE', forceFetch, preview, cachedResponse)
        return cachedResponse
      } else {
        return outputResponse
      }
    }

    // The HTTP 304 status code, “Not Modified,” tells the client that the
    // requested resource hasn't changed since the last access
    if (originResponse.statusCode === 304) {
      // We set the attributes involved in calculating the
      // age of the content.
      const multi = server.redis.multi()
      cachedResponse.requestTime = requestTime
      multi.json.set(path, '$.requestTime', requestTime)
      cachedResponse.responseTime = responseTime
      multi.json.set(path, '$.responseTime', responseTime)
      if ('date' in originResponse.headers) {
        aorh(cachedResponse, { date: originResponse.headers.date })
        multi.json.set(path, '$.headers.date', cachedResponse.headers.date)
      }
      // Update the cache
      try {
        await multi.exec()
      } catch (err) {
        server.log.error(err, `Error while storing in the cache. Origin: ${server.name}. Key: ${path}`)
        server.log.debug('Failed cache entry: ' + JSON.stringify(cachedResponse))
      }

      // Las siguientes modificaciones no queremos que persistan en caché.
      // Por ello clonamos la respuesta.
      outputResponse = utils.cloneAndTrimResponse(path, cachedResponse)
      aorh(outputResponse, { age: utils.calculateAge(outputResponse) })
      utils.memHeader('HIT', forceFetch, preview, outputResponse)
    } else {
      // We set the attributes involved in calculating the
      // age of the content.
      originResponse.requestTime = requestTime
      originResponse.responseTime = responseTime

      // If we are not in preview mode, it is cached.
      if (!preview) {
        // We generate a cache entry from the response.
        const cacheEntry = utils.cloneAndTrimResponse(path, originResponse)

        // Apply transformations to the cache entry
        // _transform(TARGET_TYPE_CACHE, ...);

        // We parse the Cache-Control header to extract cache directives.
        const cacheDirectives = utils.parseCacheControlHeader(cacheEntry)

        // Indicates that the response is intended for a single user and must
        // not be stored by a shared cache. A private cache may store the response.
        if (Object.prototype.hasOwnProperty.call(cacheDirectives, 'private')) return

        // The cache should not store anything about the client request
        // or server response.
        if (Object.prototype.hasOwnProperty.call(cacheDirectives, 'no-store')) return

        // Storing in the cache
        const multi = server.redis.multi()
        multi.json.set(path, '$', cacheEntry)
        const ttl = _ttl(cacheEntry.ttl)
        if (ttl) multi.expire(path, ttl)
        try {
          await multi.exec()
        } catch (err) {
          server.log.error(err, `Error while storing in the cache. Origin: ${server.name}. Key: ${path}`)
          server.log.debug('Failed cache entry: ' + JSON.stringify(cacheEntry))
        }
      }

      // Se clona la respuesta del origen y se le aplican
      // transformaciones para su salida.
      outputResponse = utils.cloneAndTrimResponse(path, originResponse)
      // _transform(TARGET_TYPE_RESPONSE, ...);
      aorh(outputResponse, { age: utils.calculateAge(outputResponse) })
      utils.memHeader('MISS', forceFetch, preview, outputResponse)
    }

    return outputResponse
  }

  function _fetch (options) {
    // Transformacion cuando es una request
    // _transform(TARGET_TYPE_REQUEST, ...);
    return new Promise((resolve, reject) => {
      if (server.origin.http2) {
        // TODO: Implement HTTP2 support
      } else {
        // The default protocol is 'http:'
        const request = (server.origin.httpxoptions.protocol === 'https:' ? https : http)
          .get(options, (res) => {
            let rawData = ''
            res.on('data', chunk => { rawData += chunk })
            res.on('end', () => {
              resolve({ statusCode: res.statusCode, headers: res.headers, body: rawData })
            })
          })
        request.on('error', reject)
      }
    })
  }

  /**
   * If the response does not have a TTL, it is assigned Infinity by default
   * which results in a TTL of 0 being returned.
   * This subsequently causes the cache entry not to expire.
   */
  function _ttl (ttl = 'Infinity') {
    if (ttl === 'Infinity' || Infinity === ttl) return 0
    return parseInt(ttl)
  }
}
